# 综合实验报告

## 系统设计部分

### 架构设计说明

对于最小操作系统的引导过程，

```
CPU 上电/复位
        │
        ▼
QEMU 模拟硬件 → PC 指向内核 ELF 的 _entry（0x80000000）
        │
        ▼
entry.S（汇编入口）
  ├─ 设置栈指针 sp
  ├─ 清零 BSS 段（未初始化全局变量置 0）
  └─ call start() → 跳到 C 代码
        │
        ▼
start.c / start()
  ├─ 初始化硬件/设备（比如 UART）
  └─ 调用 uart_puts("Hello OS")
        │
        ▼
UART MMIO 寄存器 → QEMU 捕获输出 → 终端显示 "Hello OS"

```

**CPU 上电后最先执行什么？**

* CPU 上电后，会从一个固定的 **复位向量** 地址开始取指执行。

* 在 QEMU 的 `riscv64` + `-kernel` 模式下，它会跳转到 **0x80000000**，这就是为什么我们在 `kernel.ld` 里写：

  ```
  . = 0x80000000;
  ENTRY(_entry);
  ```

* 所以最先执行的就是 `entry.S` 里的 `_entry` 汇编代码

------

**为什么要先建立栈？**

* C 语言函数会使用 **栈** 来保存局部变量、保存返回地址、传递参数。

* 如果没有栈，进入 C 函数时，编译器生成的 `addi sp, sp, -16` 等指令就会写到乱七八糟的内存里，导致异常。

* 所以在 `_entry` 里通常要先：

  ```
  la sp, stack0   # 把栈顶地址放到 sp
  ```

* 这样，之后才能安全地 `call start` 进入 C 代码。

------

**如何清零内存中的 BSS 段？**

- C 语言有个规则：**未初始化的全局变量必须默认为 0**，这些变量存放在 BSS 段。

- 链接脚本里会提供两个符号：

  ```
  __bss_start = .;
  *(.bss .bss.*)
  __bss_end = .;
  ```

- 然后在 `entry.S` 里写：

  ```
  la a0, __bss_start   /* 将符号地址载入 a0 */
      la a1, __bss_end     /* 将符号地址载入 a1 */
  1:  beq a0, a1, 2f
      sb zero, 0(a0)
      addi a0, a0, 1
      j 1b
  ```

- 在进入 C 代码前就保证了全局未初始化变量为 0。

------

**如何把执行从汇编代码切换到 C 语言代码？**

- 汇编里用 `call`（或 `jal`) 跳转到 `start`：

  ```
  la sp, stack0
  call start
  ```

- `start` 是在 C 文件里写的函数。

- 这样，CPU 从纯汇编环境进入了标准的 C 运行环境。

------

**如何用串口（UART）输出最简单的字符？**

- RISC-V QEMU 模拟的 **UART0 基址**是 `0x10000000`。

- UART 有一个 **传输保持寄存器 (THR)**，写一个字节进去就会发出去。

- 最小 C 实现：

  ```
  #define UART0 0x10000000L
  void uart_putc(char c) {
      volatile unsigned char *thr = (unsigned char *)UART0;
      *thr = c;
  }
  ```

- 输出字符串：

  ```
  void uart_puts(const char *s) {
      while (*s) uart_putc(*s++);
  }
  ```

------

## 实验过程部分

### 理解xv6启动流程

通过阅读entry.S和kernel.ld，我进行了一些分析：

**为什么第一条指令是设置栈指针？**

- CPU 上电后，寄存器都是随机值（或未定义值）。
- C 语言函数需要用 **栈** 来保存局部变量、调用现场（返回地址、保存寄存器等）。
- 如果不先设置 `sp`，一旦调用 C 函数就会崩溃。
- 所以第一件事就是 `la sp, stack0`，为当前 CPU 设置一块合法的栈内存。

------

**`la sp, stack0` 中的 `stack0` 在哪里定义？**

`stack0` 是在 **C 文件里定义的全局数组**，比如在 `start.c`：

```
#define NCPU 4
__attribute__ ((aligned (16))) char stack0[4096 * NCPU];
```

这样就分配了一个全局数组，作为所有 CPU 的栈空间。
汇编里的 `la sp, stack0` 会把它的起始地址加载到 `sp`。
然后根据 `mhartid`（CPU ID）计算偏移，每个核分配自己的 4KB 栈。

------

**为什么要清零 BSS 段？**

- BSS 段存放 **未初始化的全局变量**（例如 `char stack0[4096*NCPU];` 默认初始值是 0）。
- 链接时，BSS 只是占位置，不会在镜像文件里保存实际内容。
- 因此需要在启动时手动把这一段内存清零，才能保证 C 代码里用到的全局变量初始为 0。

------

**`ENTRY(_entry)` 的作用是什么？**

- `ENTRY(_entry)` 是 **链接器指令**，告诉链接器程序的入口点在哪里。
- 在 RISC-V 的 xv6 中，入口点就是汇编文件 `entry.S` 里的 `_entry` 标签。
- 当 CPU 上电运行到加载的镜像时，它会从这个入口地址开始执行，也就是 `_entry` 处的代码。

------

**为什么代码段要放在 `0x80000000`？**

- RISC-V 的 **QEMU virt** 机器（以及很多硬件）约定内存的起始物理地址是 `0x80000000`。
- Boot ROM 会把内核加载到这个地址。
- 所以为了保证 CPU reset 后能从这里取指，内核必须链接到 `0x80000000`。
- 换句话说，这是 **硬件规定的内存映射基地址**。

------

**`etext`、`edata`、`end` 符号有什么用途？**

这些是链接器自动生成的符号，用来标记内存布局的关键边界：

- **`etext`**
  - 指向 **代码段（text segment）结束的位置**。
  - 一般用于调试或保护，知道代码段结束、数据段开始。
- **`edata`**
  - 指向 **已初始化数据段（data segment）结束的位置**。
  - 可以用来判断全局已初始化变量存放区域的边界。
- **`end`**
  - 指向 **BSS 段结束的位置**，即内核静态分配的内存（未初始化全局变量）结束的地方。
  - 内核在运行时可以从 `end` 开始作为动态分配的堆或内核内存管理的起始位置。

------

### 设计最小启动流程

**最小系统启动流程图**

```
CPU 上电复位
        │
        ▼
取指 PC = 0x80000000 (由 QEMU virt 定义)
        │
        ▼
entry.S (_entry)
  ├─ 设置 sp = stack0 顶部
  ├─ 清零 .bss 段 (__bss_start → __bss_end)
  └─ call start (进入 C)
        │
        ▼
start.c (C 语言)
  ├─ 调用 uart_init (初始化串口)
  ├─ 调用 uart_puts("Hello OS\n")
  └─ 进入 while(1) 循环 (内核主循环 / 等待中断)
        │
        ▼
操作系统运行中
```

------

**内存布局方案**

典型的最小 RISC-V OS 内存布局（对应 `kernel.ld`）：

```
(高地址)
+------------------+  
|                  |
|   stack0[] 数组   |  <-- 作为栈区 (4096*NCPU)
|    (在 .bss 内)   | 
|                  |
+------------------+  
|                  |
|   其他 .bss 变量   |
|                  |
+------------------+  <-- __bss_end (ebss)
|                  |
|   .bss Section   |  (未初始化的全局/静态变量)
|                  |
+------------------+  <-- __bss_start (sbss)
|                  |
|   .data Section  |  (已初始化的全局/静态变量)
|                  |
+------------------+
|                  |
|  .rodata Section |  (只读数据, 如字符串常量)
|                  |
+------------------+ 
|                  |
|   .text Section  |  (所有机器指令)
|                  |
+------------------+  <-- 0x80000000 (内核加载与执行的起始地址)
(低地址)

```

关键符号：

- **etext** → `.text` 末尾
- **edata** → `.data` 末尾
- **end**   → `.bss` 末尾（堆的起点）
- **stack0** → 在 C 里用数组定义，汇编 `la sp, stack0` 用

------

**必需的硬件初始化步骤**

1. **建立内核栈**
   - 必须，保证 C 函数调用能运行。
   - `entry.S` 里 `la sp, stack0; addi sp, sp, 4096`。
2. **清零 BSS 段**
   - 确保未初始化的全局变量都从 0 开始，符合 C 语言语义。
   - `entry.S` 循环从 `__bss_start` 到 `__bss_end` 写 0。
3. **初始化串口 (UART)**
   - 设置 UART 寄存器，保证能正确收发。
   - 最小实验可直接轮询发送，不初始化波特率寄存器也能在 QEMU 输出。
   - 你写的 `uart_putc` → 检查 `LSR_TX_IDLE` → 写 `THR`。

------

**栈应该放在内存的哪个位置？需要多大？**

- **位置**：
   在最小实验系统里，栈可以直接**静态分配在内核的 `.bss` 段**里，例如：

  ```
  #define NCPU 1
  __attribute__((aligned(16))) char stack0[4096 * NCPU];
  ```

  然后在 `entry.S` 里：

  ```
  la sp, stack0
  addi sp, sp, 4096   # 指向栈顶
  ```

  这样栈就是编译时就确定的，放在内核镜像的 BSS 里，地址固定。

  在更复杂的系统（比如 xv6），会把每个 CPU 的栈单独分配在高地址空间，用页对齐保护，防止栈溢出破坏数据。

- **大小**：

  - 最小实验：`4 KB`（一个页大小）足够跑 `Hello OS`。
  - 实际内核：往往每 CPU 给 1 页 ~ 2 页作为内核栈。
  - 栈太小会导致函数调用嵌套多时溢出。

------

**是否需要清零 BSS 段？为什么？**

- **必须清零**。C 标准规定：**未初始化的全局/静态变量应为 0**。链接器把 BSS 只标记为占位，不会在镜像中存实际数据，因此在启动时必须把 `__bss_start``__bss_end` 全部写 0。

- 或者也可以把清零放到 C 层（`for (p=__bss_start; p<__bss_end; p++) *p=0;`），但必须在进入任何依赖全局变量的 C 代码之前完成。你现在在汇编完成清零，C 层就不必重复。

------

**最简串口输出需要配置哪些寄存器？**

针对 QEMU `virt` 上常见的 **16550-like UART**（基址 `0x10000000`）：

- **最小需要用到的寄存器**
  - `THR` (offset `0`)：Transmit Holding Register，写字符发送。
  - `LSR` (offset `5`)：Line Status Register，检查发送是否就绪（`LSR_TX_IDLE = 1<<5`）。
- **轮询发送 (最简、可靠)**：

```
#define UART0 0x10000000UL
#define Reg(reg) ((volatile unsigned char *)(UART0 + (reg)))
#define THR 0
#define LSR 5
#define LSR_TX_IDLE (1<<5)
#define ReadReg(r) (*(Reg(r)))
#define WriteReg(r,v) (*(Reg(r)) = (v))

void uart_putc(char c) {
    while ((ReadReg(LSR) & LSR_TX_IDLE) == 0) ; // 等待可写
    WriteReg(THR, (unsigned char)c);
}

void uart_puts(const char *s) {
    while (*s) uart_putc(*s++);
}
```

- 在 QEMU 的 `virt` 机型上，**通常无需额外配置波特率/LCR** 即可通过 `THR` 写出字符（用 `-nographic` 会把串口输出到宿主终端）。

------

### 实现启动汇编代码

~~~
.section .text
.global _entry
_entry:
    la sp, stack0
    li a0, 1024*4
    csrr a1, mhartid
    addi a1, a1, 1
    mul a0, a0, a1
    add sp, sp, a0
    /* --- 汇编清零 bss --- */
    la a0, __bss_start   /* 将符号地址载入 a0 */
    la a1, __bss_end     /* 将符号地址载入 a1 */
1:  beq a0, a1, 2f
    sb zero, 0(a0)
    addi a0, a0, 1
    j 1b
2:  /* 清零完成，跳到 C 的 start */
    call start
spin:
    j spin
~~~

根据PPT中的提示，实现启动汇编代码，设置入口与栈指针，清空bss，调用start开始函数。

### 编写链接脚本

~~~
OUTPUT_ARCH( "riscv" )
ENTRY( _entry )

SECTIONS
{
  . = 0x80000000;

  .text : {
    *(.text .text.*)
    PROVIDE(etext = .);
  }

  .rodata : {
    . = ALIGN(16);
    *(.srodata .srodata.*) /* do not need to distinguish this from .rodata */
    . = ALIGN(16);
    *(.rodata .rodata.*)
  }

  .data : {
    . = ALIGN(16);
    *(.sdata .sdata.*) /* do not need to distinguish this from .data */
    . = ALIGN(16);
    *(.data .data.*)
  }

  .bss : {
    . = ALIGN(16);
    __bss_start = .;
    *(.sbss .sbss.*)
    *(.bss .bss.*)
    . = ALIGN(16);
    __bss_end = .;
  }

  PROVIDE(end = .);
}
~~~

这一部分没什么特殊的，参考xv6代码，直接进行仿照，在 bss 块内要对 `__bss_start` 与 `__bss_end` 进行定义。

### 实现串口函数

~~~
#include <stdint.h>

#define UART0 0x10000000UL

#define Reg(reg) ((volatile unsigned char *)(UART0 + reg))

#define RHR 0                 // receive holding register (for input bytes)
#define THR 0                 // transmit holding register (for output bytes)
#define IER 1                 // interrupt enable register
#define IER_RX_ENABLE (1<<0)
#define IER_TX_ENABLE (1<<1)
#define FCR 2                 // FIFO control register
#define FCR_FIFO_ENABLE (1<<0)
#define FCR_FIFO_CLEAR (3<<1) // clear the content of the two FIFOs
#define ISR 2                 // interrupt status register
#define LCR 3                 // line control register
#define LCR_EIGHT_BITS (3<<0)
#define LCR_BAUD_LATCH (1<<7) // special mode to set baud rate
#define LSR 5                 // line status register
#define LSR_RX_READY (1<<0)   // input is waiting to be read from RHR
#define LSR_TX_IDLE (1<<5)    // THR can accept another character to send

#define ReadReg(reg) (*(Reg(reg)))
#define WriteReg(reg, v) (*(Reg(reg)) = (v))

/* 单字节写入（非常简化） */
void uart_putc(char c) {
    
    while((ReadReg(LSR) & LSR_TX_IDLE) == 0)
    ;
    /* 对于 QEMU virt 的简单实验，直接写数据寄存器通常就能输出 */
    WriteReg(THR,c);
}

/* 字符串输出 */
void uart_puts(const char *s) {
    while (*s) uart_putc(*s++);
}
~~~

关于这一部分，我在前文的 UART 的最小 C 实现中的写法与这里不同，是因为我考虑到在 QEMU virt 里直接写 THR 通常没问题，因为模拟器吞吐快，THR 很快被清空，几乎不会丢字节。但在真实硬件或慢速串口上，如果你不停写，而 UART 还没准备好，下一个字节会覆盖上一个 → 造成**丢字节**。

因此我在这里还是参考了官方xv6文档，虽然有些define还没用，但之后可能会有用，一起复制了过来，在写 THR 之前检查 LSR.bit5（THRE），保证其健壮性。

### 完成 C 主函数

~~~c
#define NCPU 4
__attribute__ ((aligned (16))) char stack0[4096 * NCPU];

void uart_puts(const char *s);

void start(void) {
    uart_puts("Hello OS\n");
    while (1) {
    }
}
~~~

只需要调用串口相关输出函数即可，输出结束后死循环阻塞主函数。

## 测试验证部分

### 编写Makefile

```makefile
# 交叉编译工具链前缀
CROSS_COMPILE = riscv64-unknown-elf-
CC      = $(CROSS_COMPILE)gcc
OBJCOPY = $(CROSS_COMPILE)objcopy

# 编译选项：使用 medany（允许放到 0x80000000 这类地址）
CFLAGS  = -march=rv64gc -mabi=lp64 -mcmodel=medany -O2 -Wall -ffreestanding -nostdlib
# 链接选项：使用 medany，并且在链接时也不要链接标准库
LDFLAGS = -T kernel/kernel.ld -mcmodel=medany -nostdlib

# 内核目录
K = kernel

# --------------------------------------------------
# 方法一：显式列出核心文件
OBJS := \
    $(K)/entry.o \
    $(K)/start.o  \
    $(K)/uart.o

# 方法二：自动收集目录下的所有 .c/.S 文件
CSRCS := $(wildcard $(K)/*.c)
SSRCS := $(wildcard $(K)/*.S)
AUTO_OBJS := $(CSRCS:.c=.o) $(SSRCS:.S=.o)

# 最终使用哪一组对象文件：
# 在这里切换
 OBJS_ALL = $(OBJS)        # 手动列清单
# OBJS_ALL = $(AUTO_OBJS)     # 自动收集

# --------------------------------------------------

all: kernel.elf

# 规则：汇编文件
$(K)/%.o: $(K)/%.S
	$(CC) $(CFLAGS) -c $< -o $@

# 规则：C 文件
$(K)/%.o: $(K)/%.c
	$(CC) $(CFLAGS) -c $< -o $@

# 链接
kernel.elf: $(OBJS_ALL)
	$(CC) $(LDFLAGS) -o $@ $(OBJS_ALL)

# 生成二进制镜像
kernel.bin: kernel.elf
	$(OBJCOPY) -O binary kernel.elf kernel.bin

# QEMU 运行
qemu: kernel.elf
	qemu-system-riscv64 -machine virt -nographic -bios none -kernel kernel.elf

# 清理
clean:
	rm -f $(K)/*.o kernel.elf kernel.bin

```

对于makefile的编写，只需要参考xv6和大模型提供的一点帮助，就可以很轻松地写出来。

#### 1. 工具链配置

```
# RISC-V 交叉工具链前缀
CROSS_COMPILE = riscv64-unknown-elf-
CC      = $(CROSS_COMPILE)gcc
OBJCOPY = $(CROSS_COMPILE)objcopy
```

- **CROSS_COMPILE**: 指定交叉编译工具链前缀（这里用 `riscv64-unknown-elf-`）。
- **CC**: 设置编译器为 `riscv64-unknown-elf-gcc`。
- **OBJCOPY**: 设置目标文件格式转换工具为 `riscv64-unknown-elf-objcopy`。

------

#### 2. 编译和链接选项

```
# 编译选项：使用 medany（允许放到 0x80000000 这类地址）
CFLAGS = -march=rv64gc -mabi=lp64 -mcmodel=medany -O2 -Wall -ffreestanding -nostdlib
# 链接选项：使用 medany，并且在链接时也不要链接标准库
LDFLAGS = -T kernel.ld -mcmodel=medany -nostdlib
```

- `-march=rv64gc`：目标架构是 RISC-V 64 位，带 G 扩展（整数/乘除/原子/浮点/双精度）。
- `-mabi=lp64`：ABI 为 LP64（long 和 pointer 是 64 位，int 是 32 位）。
- `-mcmodel=medany`：**位置无关代码模型**，允许加载任意 2GB 范围内的地址 → 这是为了能放到 `0x80000000` 这样的大地址运行。
- `-O2`：优化等级，生成更高效代码。
- `-Wall`：启用所有常见警告。
- `-ffreestanding`：表示是一个裸机环境（没有标准库，没有 main 函数）。
- `-nostdlib`：禁止链接任何标准 C 库或启动文件（因为我们要写自己的 entry）。
- `-T kernel.ld`：指定链接脚本 `kernel.ld`，控制内存布局。

------

#### 3. 要编译的目标文件

```
OBJS = entry.o start.o uart.o
```

这里指定了内核由三个文件组成：

- `entry.S`：汇编入口，负责设置栈、清零 BSS、跳转到 C。
- `start.c`：C 语言的启动代码（比如打印字符串）。
- `uart.c`：UART 串口驱动，负责最小输出。

------

#### 4. 编译规则

```
%.o: %.S
	$(CC) $(CFLAGS) -c $< -o $@

%.o: %.c
	$(CC) $(CFLAGS) -c $< -o $@
```

- 定义了 **模式规则**。
- `%.o: %.S`：把汇编 `.S` 文件编译成 `.o`。
- `%.o: %.c`：把 C 文件 `.c` 编译成 `.o`。
- `$<`：代表输入文件（源文件）。
- `$@`：代表输出文件（目标文件）。

------

#### 5. 链接规则

```
# 用 gcc 驱动链接，但同时明确 -nostdlib（放在 LDFLAGS 中）
kernel.elf: $(OBJS)
	$(CC) $(LDFLAGS) -o $@ $(OBJS)
```

- 把所有 `.o` 链接成 `kernel.elf`。
- 使用 `gcc` 来驱动链接（而不是直接 `ld`），这样会自动带上一些默认参数（但我们加了 `-nostdlib`，避免链接 libc）。
- `-T kernel.ld` 控制段的布局（代码放到 0x80000000，BSS 段符号导出等）。

------

#### 6. 转换成裸机二进制

```
kernel.bin: kernel.elf
	$(OBJCOPY) -O binary kernel.elf kernel.bin
```

- 把 ELF 格式（带符号表和调试信息）转换成最小的 **纯二进制镜像**。
- `kernel.bin` 就是可以直接烧进 flash 或者提供给仿真的纯裸机镜像。

------

#### 7. 在 QEMU 里运行

```
qemu: kernel.elf
	qemu-system-riscv64 -machine virt -nographic -bios none -kernel kernel.elf
```

- 运行 QEMU，模拟一个 RISC-V 64 位 `virt` 机器。
- `-nographic`：关闭图形界面，使用串口（stdout）输出。
- `-bios none`：不使用 QEMU 内置 BIOS，直接跳到内核入口（`0x80000000`）。
- `-kernel kernel.elf`：指定要加载的内核文件。

------

#### 8. 清理

```
clean:
	rm -f *.o kernel.elf kernel.bin
```

- 删除所有中间文件和目标文件，恢复到干净状态。

对于上述的 `Makefile`我写的方法二：自动收集目录下的所有文件，在实际上是不可行的，入口点 `_entry` 没有被正确放在第一个目标文件，而手写的`entry.o`永远在最前面，因此我会在实际文件中删去这一段。

### 其他问题

除了上面提到的两个问题之外，另一个问题就是在`qemu`的时候没有加`-bios none` qemu 自动加载了 **OpenSBI** 。这会导致一些指令失效，因此一定要加上 `-bios none` ，直接执行 `_entry`。

### 运行结果

~~~
make qemu
riscv64-unknown-elf-gcc -march=rv64gc -mabi=lp64 -mcmodel=medany -O2 -Wall -ffreestanding -nostdlib -c kernel/entry.S -o kernel/entry.o
riscv64-unknown-elf-gcc -march=rv64gc -mabi=lp64 -mcmodel=medany -O2 -Wall -ffreestanding -nostdlib -c kernel/start.c -o kernel/start.o
riscv64-unknown-elf-gcc -march=rv64gc -mabi=lp64 -mcmodel=medany -O2 -Wall -ffreestanding -nostdlib -c kernel/uart.c -o kernel/uart.o
riscv64-unknown-elf-gcc -T kernel/kernel.ld -mcmodel=medany -nostdlib -o kernel.elf kernel/entry.o kernel/start.o kernel/uart.o        
/opt/riscv/bin/../lib/gcc/riscv64-unknown-elf/15.1.0/../../../../riscv64-unknown-elf/bin/ld: warning: kernel.elf has a LOAD segment with RWX permissions
qemu-system-riscv64 -machine virt -nographic -bios none -kernel kernel.elf
Hello OS

~~~

